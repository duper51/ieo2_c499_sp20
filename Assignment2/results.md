# Assignment 2

## Finding a thing to test
In order to find a suitable library to test, I attempted to find C libraries with low fork counts. I did this by searching in GitHub for all projects with primarily "C" source code, containing the word "lib". I then used the advanced search function to remove any projects that had more than 5 forks of its source. I chose this so that I would be able to run code that hasn't been independently checked for obvious bugs, increasing the liklihood that I find something.

## In comes c_printf
The second result on this search that I had created was a quaint library named "c_printf". It stuck out to me as it claimed to replicate exactly the behavior of the standard "printf", with the added benefit of color support built-in. This implies that they had built a custom string parser, or some other variant to get this to work. This opens the project up to potential buffer overruns (which happens to be exactly what I found).

## On to testing
The first thing I jumped right into with the assumption in mind that there would likely be a buffer overrun somewhere in this project, was write a DeepState test that injected the test string directly into the format parameter of c_printf. After writing it all up, I was ready to test it. I figured I would start with the libFuzzer extension of DeepState, since it would support AddressSanitizer right out of the box. I configured my Makefile with the necessary options, including `-fsanitize=fuzzer,address`. Sure enough, in seconds, my suspicions were confirmed. LibFuzzer came back with a massive stack trace that landed a buffer overrun right in the middle of the library's parser. It appears that in the process of making a buffer, somewhere along the way, it made a 0-byte buffer, then attempted to read from the first byte, thus landing a buffer overrun. 

## A second opinion?
I decided I wasn't satisfied with the results of just one fuzzer, so I decided it would be worthwhile to setup a standard DeepState fuzzer. I setup DeepState to run, but without Address Sanitizer, I was less than hopeful that DeepState would be able to detect an issue. Sure enough, DeepState ran past this "empty string" bug that I had found, and started fuzzing the actual parser. This led to a lot of "bad format string" errors, which led me to stop testing. Since I had piped the fake string directly into the parser, I had expected it to fail with some sort of error related to passing a format string with no arguments (leading to a segfault). Unfortunately, I didn't notice right away that there were hundreds of memory core dumps being written because I hadn't seen them being written (the logs were piled with "unsupported format specifier"). Sure enough, format specifiers were being passed that were either invalid, or not backed up with supporting varargs. I've included a few of these crashes in this repository. 

## Analysis
I believe that the only bug that I was really able to pull out was the zero length string bug. The zero length string results in the software automatically writing a null character to a non-existent first byte. The solution would be to guard the software against processing empty format strings. I would point out, however, that this is a bug that should never appear in production because you should never pass user provided input into the format string parameter of a printf style function. This generally results in bad things, such as many of the "easy" code injection vulnerability challenges found around the net. It can lead to information disclosure at best, or straight up return pointer manipulation at worst. I was more interested in finding "a bug" than a bug that would actually affect production systems, which is why I was more interested in how the software handled its parsing.
